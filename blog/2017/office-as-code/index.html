<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Jon Lauridsen</title><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="/main.css"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item home"><a href="/" target="_self" class="link">Home</a></li><li class="nav-list-item blog"><a href="/blog/" target="_self" class="link active">Blog</a></li></ul><hr></header><section class="container"><article data-datetime='"2017-03-19T13:02:43.000Z"' class="post-block"><div class="info"><h1 class="title"><a href="/blog/2017/office-as-code/" target="_self" class="link">Office as Code</a></h1><div class="date">Mar 19, 2017</div><div title="Pre-release alpha" class="post-state alpha">Alpha</div></div><div class="content"><div class="excerpt"><p>Once upon a time developers would finish code and just chuck it over the wall to operations, relying on them to deploy and maintain the system. Then as <em>#devops</em> and <em>infrastructure-as-code</em> became popular developers got to iterate on, and take responsibility for, all those important downstream concerns that affect customers.</p><p>What about <em>upstream</em> concerns though? Think of all the office-processes that shape the environment we work in, they drive how efficient and happy we are in our daily work but I’ve often found them difficult to change. What would it look like if we applied some of the same thoughts to those factors?</p></div><div class="more"><h1>The problem</h1><p>I’ve suggested changes to offices I’ve worked in, but my efforts have regularly failed because the office-processes weren’t set up to accept changes.</p><p>For example:</p><ul><li><em>What software comes pre-installed on new machines?</em> Old or missing applications are annoying to deal with again and again, but to change the list I would have had to persuade someone from IT to go through a bothersome process of updating an old image they restore from.</li><li><em>Which sodas are stocked in the fridge?</em> I’ve had trouble just finding the person responsible, and then they weren’t open for suggestions because they felt the current solution was good enough.</li><li><em>What should a new hire do to get started as quickly as possible?</em> This is often a list somewhere, but rarely is it up-to-date or even easy to follow. I found most regulars had not read it since they started themselves.</li><li><em>What’s the coding style?</em> This too is often written down, but how can I provide my feedback to promote best-practices? I want to make a change-proposal that should be discussed before forcing it on everyone.</li></ul><p>I think the fundamental problem I encountered is that many office-processes are rigid, instead of being set up for iterative improvements. A process that supports iterative improvements should have a change-management structure that welcomes small, well-defined incremental steps, where each successful step becomes the baseline that everyone adopts. In contrast a process becomes rigid when it’s controlled by whoever happens to be doing it and there is no system for improvement.</p><p>In those situations it doesn’t matter if you talk to the person directly, email them, or have a fancy ticketing system, it all comes down to the same problem: If they feel the current system works well enough then your unsolicited suggestion is not worth implementing. Their workflow may even be archaic and ineffective so your “simple” suggestion could be complicated to implement. And to play devil’s advocate, why <em>should</em> your suggestion be listened to? How can you prove you speak for everyone your suggestion affects?</p><p>Rigid processes easily end up amplifying dysfunctions, doing nothing to avoid those pitfalls.</p><h2>The Wiki</h2><p>We need a quick detour into wikis before proceeding. If a process is described in a wiki then that’s good right? I don’t think so, wikis really aren’t fit for describing processes at all:</p><p>First, it’s rare a wiki page is the <em>source</em> of information, most pages are the <em>output</em> of a decision and whoever performs the task doesn’t actually look at that page anymore (and many pages thus grow totally inaccurate over time). Editing a page like that will have little effect, if no-one actually reads it why bother updating it?</p><p>And secondly wiki edits go live immediately, but that cuts out the critical discussion step. Without discussion changes will go in that some people are unaware of or disagree with, and so the change is not effective.</p><p>Thirdly, it can be intimidating to alter someone’s text (especially as a new hire) which further limits which suggestions you get. A new hire is unlikely to suggest a radically different approach to a process, even if they have a great idea to suggest.</p><h1>The solution</h1><p>I’m looking for a way to solve for the following challenges:</p><ul><li>How do you <em>know</em> how well your current process works? There should be room for discussion, a platform with low barriers of entry that invites suggestions.</li><li>How can you tell which are popular suggestions? There should be an easy way for others to passively show support, like a voting-system.</li><li>How is the process optimized over time? If a process can be done by anyone, by following a series of steps, then it will benefit from many more eyes on the process, and the steps can be optimized over time.</li></ul><p>That… actually sounds a lot like a <em>pull-request</em>, doesn’t it? A pull-request is a safe space for changes of any size to be discussed and broad consensus reached <em>before</em> merging it in. That means every interested party is kept up-to-date and in agreement, and it vastly lowers the barrier of entry for suggesting changes because a pull-request is just a request, it’s safe to suggest big changes or come up with a rough outline and hash out the details in public. Pull-requests also invite remixing when other people branch off your change to inject their suggestions. And of course repositories exists within an ecosystem of tools and libraries that facilitate powerful automation.</p><h2>Everything’s a repository</h2><p>So let’s try an experiment, can we take our examples from before and somehow turn them into “office-code”?</p><p>The most critical change is a cultural one: We must be able to capture a process such that the captured information is the <strong>source</strong> of information, because no amount of tooling can reach what only exists in the heads of a few individuals. Changing culture can be hard, but it all starts with changing what people <em>do</em>. I think if we use a tool that’s designed for being the source of information, i.e., repositories, then it makes it easier for everyone to grok this idea.</p><p>I propose we don’t need to capture computer-executable code though, that’d be taking the repository-thinking too literally. To start with it’ll be enough to capture these details as “human-executable” instructions, and focus on a culture of open discussions, iterative improvement, and broaden the set of people who performs the task.</p><hr><p>So, how do we deal with pre-installed software? To cover the basics we can provide a link to the OS image and a description of how to format and reset machines. At least this way anyone can reset machines without having to contact IT.</p><p>To better use the power of repositories we can add some automation. What if applications were specified as installation-scripts (e.g. <a href="https://www.chef.io/chef/">Chef</a>)? And we re-generate the disk image whenever <code>master</code> is updated. That would make it simple for anyone to add or update preinstalled applications, and it’s the kind of automation that’s straightforward to do in a repository.</p><hr><p>Same approach for the office fridge. Forget about someone keeping an arbitrary list on their desk, now we have a <code>fridge-stocking.git</code> repo containing the necessary steps to make and change orders. If we specify the actual sodas to order in a separate file it’ll be easy to propose stocking a specific drink by just creating a pull-request.</p><p>For expense reasons maybe the power to purchase is limited to one person, but they can look at the rich feedback in a pull-request, like its comments and how many thumbs-up it has, to decide which requests to merge in and which to deny.</p><hr><p>Capturing new-hire checklists and the coding-style into repositories means we can use those pull-requests for suggesting changes. Each change can be thoroughly discussed, so when it’s merged in everyone is onboard with it.</p><p>With such an inviting change-management approach perhaps we can even consider a new rule: What if every new hire is asked to make pull-requests for every topic they feel a previous company did better? So as a new hire your first task would be to go through all the office-as-code repositories and submit pull-requests describing your best experiences from past companies. Then we all discuss those changes and we merge in the ideas we love.</p><p>Wouldn’t that be a pretty elegant way of ensuring continuous improvements of the office?</p><h1>In conclusion</h1><p>Why bother with any of this though? Is it really that important? Doesn’t your office work just fine the way it is? Well… I don’t know, does it? Seriously I’d love to hear your experiences, please leave a comment so I can expand my horizons.</p><p>But I’ve felt most office-processes have been beyond my control, and when they operate less than ideally it’s a small but persistent annoyance to be unable to change it. I’ve tried reaching out with suggestions but usually get ignored or declined because of course everyone’s busy. It takes a lot of effort to persuade a person to change the way they’ve done something for years, and without a platform for discussion it’s not even really possible to show how broadly supported a suggestion is.</p><p>Wikis may appear to be a solution but they actually fail to capture processes because of their limited change-model.</p><p>Of course not everything can or should be solved by tools, but when there’s an opportunity to simplify how we work <em>and</em> better align processes to evolve iteratively why not give it a try?</p></div></div></article><div class="paginator"><a href="/blog/2016/the-trouble-with-python-packaging/" class="prev">Newer</a><a href="/blog/2017/dont-put-it-on-the-backlog/" class="next">Older</a></div><div id="disqus_thread"></div><script>var disqus_config=function(){this.page.url="http://jonlauridsen.com/blog/2017/office-as-code/",this.page.identifier="blog/2017/office-as-code/"};!function(){var e=document,t=e.createElement("script");t.src="//jonlauridsen.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)}()</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></section><footer><section class="author-info"><img src="/img/jon.jpg" alt="Picture of Jon Lauridsen" class="image profile-pic"><div class="name">Jon Lauridsen</div><div class="blurb">Software developer, and automated quality assurance aficionado.</div></section><section class="site-info"><div class="last-build">Updated <abbr title="April 17th 2017, 10:28:29" data-datetime="2017-04-17T10:28:29+00:00" class="relative-time">Apr 17th</abbr></div><div class="credit">Powered by <a href="https://hexo.io">Hexo</a></div></section></footer></div><script src="/main.js"></script><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-22672641-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script id="dsq-count-scr" async src="//jonlauridsen.disqus.com/count.js"></script></body></html>