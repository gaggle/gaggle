<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Jon Lauridsen</title><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="/main.css"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item home"><a href="/" target="_self" class="link">Home</a></li><li class="nav-list-item blog"><a href="/blog/" target="_self" class="link active">Blog</a></li></ul><hr></header><section class="container"><article data-datetime='"2016-12-19T00:47:09.000Z"' class="post-block"><div class="info"><h1 class="title"><a href="/blog/2016/the-trouble-with-python-packaging/" target="_self" class="link">The Trouble with Python Packaging</a></h1><div class="date">Dec 19, 2016</div><div title="Pre-release alpha" class="post-state alpha">Alpha</div></div><div class="content"><div class="excerpt"><p>I’ve long wished Python allowed easier handling of multiple projects and their dependencies. You know how you create a folder, fill it with code, and want to share it with others? Or maybe it’s a library to pull into your application as a dependency, instead of making one huge monolithic product? Python has <code>virtualenv</code> and <code>pip</code> for this, <code>virtualenv</code> for creating isolated environments and <code>pip</code> for downloading and managing dependencies. But they are not easy to learn, nor easy to use daily, and I dream of a better alternative.</p></div><div class="more"><p>Before I go on though, I want to state how grateful I am that <code>virtualenv</code> and <code>pip</code> exists at all. They represent countless hours of development and are good pragmatic solutions written by people much, much smarter than me.</p><p>During the writing of this blog its dawned on me that I’m probably missing some insights that explain why our tools work the way they do. If you can help fill in these blanks I’m all ears.</p><h1>The problem</h1><p>So what is it I’m complaining about? There are 3 distinctly troubled areas to go through:</p><h2>virtual<em>wha</em>??</h2><blockquote class="pullquote right"><p>What if I just don’t use them?</p></blockquote><p>To start a Python project today you must first create a new <code>virtualenv</code>, but what is that? After reading about it we learn it’s a way to isolate my Python environment, but what does <em>that</em> mean?</p><p>At first glance a <code>virtualenv</code> is this thing that puts my terminal in a different state, and if I don’t activate it nothing works. And I have to keep activating it everytime I open a terminal?</p><img src="/blog/2016/the-trouble-with-python-packaging/venv-activate.gif" alt="venv-activate.gif"><p>What if I just don’t use them? Then all my dependencies go to my system’s Python folder and cause a mess for other projects I work on… But hang on, what if I <strong>forget</strong> to activate it then? How do I even clean up the resulting mess?</p><p><code>virtualenv</code> is a brittle platform to learn from because any missteps send me tumbling down rabbit holes of googling for solutions, and even after having learnt it it’s an annoying ceremony of activating/deactivating them each time I swap projects.</p><h2>pip?</h2><p>That’s one part of the problem, but specifying dependencies is a whole thing too. <code>pip</code> is how we install dependencies and specify which libraries we rely on so that others can use <strong>our</strong> code. And it’s almost good, but manages to snatch defeat from the jaws of victory.</p><p>All it takes to install a dependency is <code>pip install [name]</code> which is just perfect. But then I go store the list of dependencies with <code>pip freeze</code> and hang on why am I seeing transient dependencies??</p><p>E.g. let’s say I want to use the <code>twisted</code> library:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(venv) python-virtualenv-experiment $ pip install twisted</div><div class="line">(venv) python-virtualenv-experiment $ pip freeze &gt; requirements.txt</div><div class="line">(venv) python-virtualenv-experiment $ cat requirements.txt</div><div class="line">constantly==15.1.0</div><div class="line">incremental==16.10.1</div><div class="line">Twisted==16.6.0</div><div class="line">zope.interface==4.3.3</div></pre></td></tr></table></figure><p>Why am I now responsible for <code>constantly</code>, <code>incremental</code>, and <code>zope</code>?? What do I do now? Delete those entries from the file? Sure, but next time I add a dependency and re-freeze they’ll be back. Gah!</p><h2>Configuration</h2><blockquote class="pullquote right"><p>Python provides no solution for managing the configuration and use of a project.</p></blockquote><p>After all that’s said and done we want to make it easy for others to use our project, i.e. they should download our code and easily get up and running.</p><p>To ease the process of installing dependencies, running tests, and starting the application we use… nothing. There’s no built-in solution for this. Python, for all its &quot;batteries included” experience, provides no solution for managing the configuration and use of a project.</p><p>Let’s say you’ve pulled a repository to help fix an issue, what do you do then? Where do you start? How do you run its tests? Maybe there’s a makefile, or .bat file, or who knows!?, it’s going to be different for every project so you better read up on their documentation. And hopefully the developers made their process compatible with your OS…</p><h1>A new approach</h1><p>These annoyances add up to make it much more difficult than necessary to get started with and continue to use Python. It’s a constant drain on productivity to continuously require activations of environments, managing dependencies, and remembering how individual projects are configured.</p><p>What if instead we had a tool that’s easy to learn, that simplifies the management and installation of dependencies, and allows everyone to get started immediately?</p><p>This tool already exists, I came across it in the JavaScript community where it’s used to great success. This whole article really boils down a simple dream: I want <code>pip</code> to be like JavaScript’s <code>npm</code>.</p><h2>npm</h2><blockquote class="pullquote right"><p>Let me say that again, <strong>no dependencies are installed to any global folder by default</strong>.</p></blockquote><p>If you’re unfamiliar with <code>npm</code> it’s the JavaScript package manager, a command line interface tool to download JavaScript modules. It exactly mirrors the role of our <code>pip</code>, but crucially provides a well-rounded set of functionality that dramatically lowers friction of dependency- and project-management compared to Python.</p><p><code>npm</code> forms the backbone of the JavaScript ecosystem by making it easy to start new projects, jump in and improve existing projects, specify and maintain dependencies, and allowing the running of tests and other related scripts.</p><p>It also does a lot more that’s unrelated to this article, but despite having a broad set of functionality it manages to be very easy to learn. I think because of these three reasons:</p><ul><li><p>Dependencies are always installed with a simple <code>npm install</code> command, which makes it trivial to get started. That’s the <strong>only</strong> command a new user has to learn to jump into JavaScript code.</p></li><li><p>Dependencies and all other configuration data is always stored in a <code>package.json</code> data file, every JS developer quickly learns to read this file and it specifies with simple clarity exactly which commands are available to run and which direct dependencies the project has:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">js-experiment $ cat package.json</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;test&quot;: &quot;karma start&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;dependencies&quot;: &#123;</div><div class="line">    &quot;express&quot;: &quot;^4.14.0&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>And perhaps most importantly, dependencies are stored in folder next to the <code>package.json</code> file. Let me say that again, <strong>no dependencies are installed to any global folder by default</strong>!</p></li></ul><p>Together the result is an easy-to-learn system because the only command to learn initially is <code>npm install</code>. With that you can install dependencies and explore existing libraries, and because it always installs to a local folder there’s never a sense of “<em>Oh crap where did all my dependencies just go? What mess did I just create?</em>”. Just delete the folder and start over.</p><blockquote class="pullquote right"><p>It’s actually <em>difficult</em> to do the wrong thing with this tool!</p></blockquote><p>Is it heretical to suggest changing where Python stores modules? It’s this change that makes <code>virtualenv</code> superfluous, because now any folder with a <code>package.json</code> file is inherently isolated. And the massive benefit is how safe it becomes to experiment and learn, because cause and effects are clear and a reset is only a deleted folder away.</p><p>And BTW, when adding new dependencies (i.e. <code>npm install express</code>) the command can <strong>automatically</strong> update the .json file. It’s actually <em>difficult</em> to do the wrong thing with this tool! This feeling of safety makes it fun to learn.</p><p>And finally <code>npm</code> exposes a way to run custom scripts, with two named hooks explicitly exposed at the top-level: <code>npm test</code> and <code>npm start</code>. Everyone configures those scripts to respectively run tests and start the package’s code, and it’s the final piece that allows for this ecosystem to be easy to learn. It means there are just two commands to be able to jump right into most JavaScript projects:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install</div><div class="line">$ npm test</div></pre></td></tr></table></figure><p>So simple.</p><p><code>npm</code> also supports running arbitrary scripts ala <code>npm run [name]</code>, so it provides this great integrated solution for easily running all manner of scripts like deploying, generating documentation, or anything at all really.</p><h1>In conclusion</h1><p>There’s more to <code>npm</code> than described here (just one example is an incredibly nice <code>npm init</code> flow that scaffolds a new <code>package.json</code> by asking the user a short set of questions), but today is just to focus on the core elements that makes Python’s project management a burden when JavaScript is easy.</p><p>In all the above examples I wish <code>pip</code> worked just like <code>npm</code>, I wish I could <code>pip install selenium</code> and see it appear as a dependency in <code>package.json</code>, I wish I could rely on the conventions of <code>pip install; pip test</code> to get started on other people’s code, and I wish I could configure my own module’s <code>package.json</code> to make it easy for others to join in.</p><p>I dream that these changes are less drastic than they sound, but the truth is I lack the insight to understand the ramifications of what I’m suggesting. If you have arguments for supporting or rejecting these thoughts I’d love to hear them!, I’m always striving to get closer to Python enlightenment and all feedback furthers that journey.</p></div></div></article><div class="paginator"><a href="/blog/2016/end-to-end-testing-with-webdriverio-sauce-labs/" class="prev">Newer</a><a href="/blog/2017/office-as-code/" class="next">Older</a></div><div id="disqus_thread"></div><script>var disqus_config=function(){this.page.url="http://jonlauridsen.com/blog/2016/the-trouble-with-python-packaging/",this.page.identifier="blog/2016/the-trouble-with-python-packaging/"};!function(){var t=document,e=t.createElement("script");e.src="//jonlauridsen.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></section><footer><section class="author-info"><img src="/img/jon.jpg" alt="Picture of Jon Lauridsen" class="image profile-pic"><div class="name">Jon Lauridsen</div><div class="blurb">Software developer, and automated quality assurance aficionado.</div></section><section class="site-info"><div class="last-build">Updated <abbr title="April 17th 2017, 10:28:29" data-datetime="2017-04-17T10:28:29+00:00" class="relative-time">Apr 17th</abbr></div><div class="credit">Powered by <a href="https://hexo.io">Hexo</a></div></section></footer></div><script src="/main.js"></script><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-22672641-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script id="dsq-count-scr" async src="//jonlauridsen.disqus.com/count.js"></script></body></html>