<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Jon Lauridsen</title><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="/main.css"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item home"><a href="/" target="_self" class="link">Home</a></li><li class="nav-list-item blog"><a href="/blog/" target="_self" class="link active">Blog</a></li></ul><hr></header><section class="container"><article data-datetime='"2016-10-27T00:15:51.000Z"' class="post-block"><div class="info"><h1 class="title"><a href="/blog/2016/selenium-testing-with-ruby-javascript-and-python/" target="_self" class="link">Selenium Testing with Ruby, JS, and Python</a></h1><div class="date">Oct 27, 2016</div><div title="Pre-release alpha" class="post-state alpha">Alpha</div></div><div class="content"><div class="excerpt"><p>UI tests, E2E tests, acceptance tests, I don’t care what we call them but today we’re going to take a practical look at writing tests that uses a real browser to find &amp; click on elements.</p></div><div class="more"><h1>Introduction</h1><p>We’ll cover the basics of getting started with UI testing, and then write a test that really interacts with a web page. I want to do this in Ruby, JavaScript, and Python, to compare and contrast the differences of each language and get a better understanding of the Selenium landscape. My choices will invariably fall short for some, but if you feel I missed something important let me know.</p><p><a href="http://docs.seleniumhq.org" title="Selenium - Web Browser Automation">Selenium</a> is the <em>de facto</em> browser automation solution, but it isn’t always easy to work with. What we need is a representative automation challenge that exercises areas of Selenium that can be tricky to work with, but without being so complex that this blog needs to be a book. Here is the automation challenge I’ve come up with:</p><ul><li>Open a Chrome browser in Incognito mode.</li><li>Go to <a href="https://the-internet.herokuapp.com/dynamic_loading/2" title="The Internet">https://the-internet.herokuapp.com/dynamic_loading/2</a>.</li><li>Click the <code>start</code> button.</li><li>Assert that the <code>Hello World</code> element is present.</li><li>And do this using the <a href="http://martinfowler.com/bliki/PageObject.html" title="PageObject">Page Object</a> pattern, because testing always requires a great deal of complexity management.</li></ul><p>By requiring Chrome in Incognito mode we must configure the webdriver to pass proper arguments, a small but classic hurdle to overcome. And the “dynamic loading” example on <code>the-internet</code> deals with having to wait for an element, which can be a tricky scenario. And using Page Objects forces us to deal with abstractions, even if they’re overkill for this specific challenge.</p><h1>Basics</h1><p>First lets solve the basics, can we open a webpage at all? Roughly speaking we need to configure a test runner, a test framework, and a Selenium-backed framework for each of our projects, and have a single command to execute tests.</p><h3>Ruby / WebDriver</h3><p>As always Ruby is easy to work with, these are the steps to get started:</p><ul><li>Install <a href="http://teamcapybara.github.io/capybara/" title="Capybara - Acceptance test framework for web applications"><code>capybara</code></a> (test framework), <a href="http://rspec.info" title="RSpec - Behaviour Driven Development for Ruby"><code>rspec</code></a> (test runner) and <a href="https://rubygems.org/gems/selenium-webdriver" title="WebDriver is a tool for writing automated tests of websites"><code>selenium-webdriver</code></a> dependencies.</li><li>Copy-paste test example.</li><li>Run <code>rspec spec</code> command.</li></ul><p>And that’s it, hard to see how it can be done simpler.</p><p>Here’s a simple test that just opens Google:</p><script src="https://gist-it.appspot.com/github/gaggle/selenium-testing-across-languages/blob/master/ruby-capybara/spec/simple_spec.rb"></script><p>All in all pretty straightforward!</p><h2>JavaScript / WD</h2><p>JavaScript is growing and there is much beauty in its vibrant community. But that also means growing pains, manifesting as multiple viable choices and version incompatibilities. I settled on <a href="http://admc.io/wd" title="WD - A node.js client for webdriver/selenium 2"><code>wd</code></a> since that worked out of the box, but still struggled to put together a solution that just worked. Where Ruby took minutes, this ended up taking more than an hour to complete the full exercise.</p><ul><li>Specify <a href="http://chaijs.com" title="Chai Assertion Library"><code>chai</code></a> + <a href="https://github.com/domenic/chai-as-promised" title="Chai-as-promised - Extends Chai with assertions about promises"><code>chai-as-promised</code></a> (assertion libraries), <a href="https://mochajs.org" title="Mocha - the fun, simple, flexible JavaScript test framework"><code>mocha</code></a> (test runner), <a href="http://admc.io/wd" title="WD - A node.js client for webdriver/selenium 2"><code>wd</code></a> (webdriver) and <a href="https://www.npmjs.com/package/selenium-standalone" title="Selenium Standalone Server"><code>selenium-standalone</code></a> as dependencies.</li><li>Hm, website doesn’t have a simple example to copy, but a lengthy file in their repo can be pruned down with a bit of effort.</li><li>Hm, the Selenium standalone server must be started in one terminal window and the tests in another…</li><li>Add <a href="http://gulpjs.com" title="gulp.js - the streaming build system"><code>gulp</code></a> (build tool) as dependency, and have it run the server and tests simultaneously so we don’t have to juggle multiple terminal windows.</li><li>Run <code>npm test</code></li></ul><p>It’s not so bad once everything works, but it sure took longer to get here than I’d like. This is the simple test:</p><script src="https://gist-it.appspot.com/github/gaggle/selenium-testing-across-languages/blob/master/js-wd/test/simple-specs.js"></script><h2>Python / Selenium-py</h2><p>As usual Python comes batteries included, the only dependency is the Selenium framework itself. Very nice! Unfortunately we do have to deal with Python’s cumbersome dependency system, but that’s an annoyance for another article. Here are the steps:</p><ul><li>Create and activate a “virtualenv” (a concept of isolating from your global Python installation so your dependencies are confined to the project’s directory. It’s a boring technicality).</li><li>Install <a href="https://seleniumhq.github.io/selenium/docs/api/py/index.html" title="Selenium Client Driver"><code>selenium-py</code></a> as a dependency (and remember to manually pipe that dependency into a <code>requirements.txt</code> file, ZZzzz).</li><li>Pretty much copy-paste example from website.</li><li>Run <code>python -m unittest discover test</code>. Jeez that’s a mouthful, and it only works if the virtualenv is active…</li><li>Create a <code>runtests.sh</code> script to automate those steps. Too bad that won’t work on Windows.</li></ul><p>Well, that wasn’t <strong>too</strong> terrible, and the test sure looks elegant:</p><script src="https://gist-it.appspot.com/github/gaggle/selenium-testing-across-languages/blob/master/py-selenium/test/test_simple.py"></script><h1>The Real Challenge</h1><p>Now to turn the simple test into one that solves our challenge.</p><h2>Ruby / WebDriver</h2><p>First lets extract configuration data to a separate file:</p><script src="https://gist-it.appspot.com/github/gaggle/selenium-testing-across-languages/blob/master/ruby-capybara/spec/spec_helper.rb"></script><p>And create a very simple page object, thanks to Capybara’s powerful DSL:</p><script src="https://gist-it.appspot.com/github/gaggle/selenium-testing-across-languages/blob/master/ruby-capybara/spec/pages.rb"></script><p>That leaves our challenge test, which is very minimal:</p><script src="https://gist-it.appspot.com/github/gaggle/selenium-testing-across-languages/blob/master/ruby-capybara/spec/challenge_spec.rb"></script><h3>JavaScript / WD</h3><p>A nice side-effect of extracting configuration is that we can also scoop out all that top-heavy module importing/glueing that clutters the test:</p><script src="https://gist-it.appspot.com/github/gaggle/selenium-testing-across-languages/blob/master/js-wd/test/conf.js"></script><p>And all the selectors and other page-specific complexities go into the page object file:</p><script src="https://gist-it.appspot.com/github/gaggle/selenium-testing-across-languages/blob/master/js-wd/test/pages.js"></script><p>Which just leaves the test, and despite the presence of some boilerplate the test itself is very minimal:</p><script src="https://gist-it.appspot.com/github/gaggle/selenium-testing-across-languages/blob/master/js-wd/test/challenge-specs.js"></script><h3>Python / Selenium-py</h3><p>Once again we extract configuration and page object:</p><script src="https://gist-it.appspot.com/github/gaggle/selenium-testing-across-languages/blob/master/py-selenium/test/conf.py"></script><script src="https://gist-it.appspot.com/github/gaggle/selenium-testing-across-languages/blob/master/py-selenium/test/pages.py"></script><p>Resulting in a very clean test file:</p><script src="https://gist-it.appspot.com/github/gaggle/selenium-testing-across-languages/blob/master/py-selenium/test/test_challenge.py"></script><h2>In conclusion</h2><p>So that’s three different takes on UI tests. If you have any comments or questions <a href="https://twitter.com/jonlauridsen">I’d love to hear them</a>, and <a href="https://github.com/gaggle/selenium-testing-across-languages" title="Selenium testing across languages">all the code is available</a> if you’d like to test these things out yourself.</p><p>The results of this fits my preconceived stereotypes of each language: <strong>Ruby</strong> is easy to get started with and easy to use, generally my first implementation would just work. <strong>Javascript</strong> is a smorgasbord of choice and everything is amazingly decoupled, but you have to glue it all together and the result is more verbose than what I consider ideal. And <strong>Python</strong> is actually very clean and easy to use, but with a slight detracting complexity in configuring its environment and I broke Windows compatibility.</p><p>For future reference here are my system versions:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ ruby -v</div><div class="line">ruby 2.3.0p0 (2015-12-25 revision 53290) [x86_64-darwin15]</div><div class="line"></div><div class="line">$ npm version</div><div class="line">&#123; npm: &apos;4.0.1&apos;,</div><div class="line">ares: &apos;1.10.1-DEV&apos;,</div><div class="line">http_parser: &apos;2.7.0&apos;,</div><div class="line">icu: &apos;57.1&apos;,</div><div class="line">modules: &apos;51&apos;,</div><div class="line">node: &apos;7.0.0&apos;,</div><div class="line">openssl: &apos;1.0.2j&apos;,</div><div class="line">uv: &apos;1.9.1&apos;,</div><div class="line">v8: &apos;5.4.500.36&apos;,</div><div class="line">zlib: &apos;1.2.8&apos; &#125;</div><div class="line"></div><div class="line">$ python --version</div><div class="line">Python 3.5.2</div></pre></td></tr></table></figure></div></div></article><div class="paginator"><a href="/blog/2016/end-to-end-testing-with-webdriverio-sauce-labs/" class="next">Older</a></div><div id="disqus_thread"></div><script>var disqus_config=function(){this.page.url="http://jonlauridsen.com/blog/2016/selenium-testing-with-ruby-javascript-and-python/",this.page.identifier="blog/2016/selenium-testing-with-ruby-javascript-and-python/"};!function(){var t=document,e=t.createElement("script");e.src="//jonlauridsen.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></section><footer><section class="author-info"><img src="/img/jon.jpg" alt="Picture of Jon Lauridsen" class="image profile-pic"><div class="name">Jon Lauridsen</div><div class="blurb">Software developer, and automated quality assurance aficionado.</div></section><section class="site-info"><div class="last-build">Updated <abbr title="April 17th 2017, 10:28:29" data-datetime="2017-04-17T10:28:29+00:00" class="relative-time">Apr 17th</abbr></div><div class="credit">Powered by <a href="https://hexo.io">Hexo</a></div></section></footer></div><script src="/main.js"></script><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-22672641-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script id="dsq-count-scr" async src="//jonlauridsen.disqus.com/count.js"></script></body></html>